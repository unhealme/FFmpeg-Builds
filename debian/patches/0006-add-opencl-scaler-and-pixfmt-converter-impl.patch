Index: FFmpeg/configure
===================================================================
--- FFmpeg.orig/configure
+++ FFmpeg/configure
@@ -3935,6 +3935,7 @@ rubberband_filter_deps="librubberband"
 sab_filter_deps="gpl swscale"
 scale2ref_filter_deps="swscale"
 scale_filter_deps="swscale"
+scale_opencl_filter_deps="opencl"
 scale_qsv_filter_deps="libmfx"
 scale_qsv_filter_select="qsvvpp"
 scdet_filter_select="scene_sad"
Index: FFmpeg/libavfilter/Makefile
===================================================================
--- FFmpeg.orig/libavfilter/Makefile
+++ FFmpeg/libavfilter/Makefile
@@ -461,6 +461,7 @@ OBJS-$(CONFIG_SCALE_FILTER)
 OBJS-$(CONFIG_SCALE_CUDA_FILTER)             += vf_scale_cuda.o scale_eval.o \
                                                 vf_scale_cuda.ptx.o cuda/load_helper.o
 OBJS-$(CONFIG_SCALE_NPP_FILTER)              += vf_scale_npp.o scale_eval.o
+OBJS-$(CONFIG_SCALE_OPENCL_FILTER)           += vf_scale_opencl.o opencl.o opencl/scale.o scale_eval.o
 OBJS-$(CONFIG_SCALE_QSV_FILTER)              += vf_vpp_qsv.o
 OBJS-$(CONFIG_SCALE_VAAPI_FILTER)            += vf_scale_vaapi.o scale_eval.o vaapi_vpp.o
 OBJS-$(CONFIG_SCALE_VT_FILTER)               += vf_scale_vt.o scale_eval.o
Index: FFmpeg/libavfilter/allfilters.c
===================================================================
--- FFmpeg.orig/libavfilter/allfilters.c
+++ FFmpeg/libavfilter/allfilters.c
@@ -433,6 +433,7 @@ extern const AVFilter ff_vf_sab;
 extern const AVFilter ff_vf_scale;
 extern const AVFilter ff_vf_scale_cuda;
 extern const AVFilter ff_vf_scale_npp;
+extern const AVFilter ff_vf_scale_opencl;
 extern const AVFilter ff_vf_scale_qsv;
 extern const AVFilter ff_vf_scale_vaapi;
 extern const AVFilter ff_vf_scale_vt;
Index: FFmpeg/libavfilter/opencl/scale.cl
===================================================================
--- /dev/null
+++ FFmpeg/libavfilter/opencl/scale.cl
@@ -0,0 +1,318 @@
+/*
+ * Copyright (c) 2018 Gabriel Machado
+ * Copyright (c) 2021 NyanMisaka
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+__constant sampler_t n_sampler = (CLK_NORMALIZED_COORDS_FALSE |
+                                  CLK_ADDRESS_CLAMP_TO_EDGE   |
+                                  CLK_FILTER_NEAREST);
+
+__constant sampler_t l_sampler = (CLK_NORMALIZED_COORDS_FALSE |
+                                  CLK_ADDRESS_CLAMP_TO_EDGE   |
+                                  CLK_FILTER_LINEAR);
+
+__constant sampler_t d_sampler = (CLK_NORMALIZED_COORDS_TRUE  |
+                                  CLK_ADDRESS_REPEAT          |
+                                  CLK_FILTER_NEAREST);
+
+#ifdef ENABLE_DITHER
+float get_dithered_y(float y, float d) {
+    return floor(y * dither_quantization + d + 0.5f / dither_size2) * 1.0f / dither_quantization;
+}
+#endif
+
+#ifdef CONV
+__kernel void conv_yuv(__write_only image2d_t dst1,
+                       __read_only  image2d_t src1,
+                       __write_only image2d_t dst2,
+                       __read_only  image2d_t src2
+  #if defined(NON_SEMI_PLANAR_OUT) && !defined(SCALE) && !defined(SCALE_BUILTIN)
+                      ,__write_only image2d_t dst3
+  #endif
+  #if defined(NON_SEMI_PLANAR_IN) && !defined(SCALE) && !defined(SCALE_BUILTIN)
+                      ,__read_only  image2d_t src3
+  #endif
+  #ifdef ENABLE_DITHER
+                      ,__read_only  image2d_t dither
+  #endif
+                       )
+{
+    int xi = get_global_id(0);
+    int yi = get_global_id(1);
+    // each work item process four pixels
+    int x = xi << 1;
+    int y = yi << 1;
+
+  #ifdef ENABLE_DITHER
+    float2 ncoords_d = convert_float2((int2)(xi, yi)) *
+        native_recip((float2)(get_image_width(dither), get_image_height(dither)));
+  #endif
+
+    if (xi >= get_image_width(dst2) || yi >= get_image_height(dst2))
+        return;
+
+  #ifndef P010LE_COMPACT_IN
+    float y0 = read_imagef(src1, n_sampler, (int2)(x,     y)).x;
+    float y1 = read_imagef(src1, n_sampler, (int2)(x + 1, y)).x;
+    float y2 = read_imagef(src1, n_sampler, (int2)(x,     y + 1)).x;
+    float y3 = read_imagef(src1, n_sampler, (int2)(x + 1, y + 1)).x;
+  #else
+    uint off0 = ((x + 0) << 1) & 7;
+    uint off1 = ((x + 1) << 1) & 7;
+    int2 pos0 = (int2)((x + 0) * 1.25f,     y + 0);
+    int2 pos1 = (int2)((x + 0) * 1.25f + 1, y + 0);
+    int2 pos2 = (int2)((x + 1) * 1.25f,     y + 0);
+    int2 pos3 = (int2)((x + 1) * 1.25f + 1, y + 0);
+    int2 pos4 = (int2)((x + 0) * 1.25f,     y + 1);
+    int2 pos5 = (int2)((x + 0) * 1.25f + 1, y + 1);
+    int2 pos6 = (int2)((x + 1) * 1.25f,     y + 1);
+    int2 pos7 = (int2)((x + 1) * 1.25f + 1, y + 1);
+    uint4 px4ui;
+    float4 px4f;
+    px4ui.x = read_imageui(src1, n_sampler, pos0).x >> off0 |
+              read_imageui(src1, n_sampler, pos1).x << (8 - off0);
+    px4ui.y = read_imageui(src1, n_sampler, pos2).x >> off1 |
+              read_imageui(src1, n_sampler, pos3).x << (8 - off1);
+    px4ui.z = read_imageui(src1, n_sampler, pos4).x >> off0 |
+              read_imageui(src1, n_sampler, pos5).x << (8 - off0);
+    px4ui.w = read_imageui(src1, n_sampler, pos6).x >> off1 |
+              read_imageui(src1, n_sampler, pos7).x << (8 - off1);
+    px4f = convert_float4((px4ui & 0x3FF) << 6) / USHRT_MAX;
+    float y0 = px4f.x, y1 = px4f.y, y2 = px4f.z, y3 = px4f.w;
+  #endif
+
+  #if defined(NON_SEMI_PLANAR_IN) && !defined(SCALE) && !defined(SCALE_BUILTIN)
+    float2 uv = { read_imagef(src2, n_sampler, (int2)(xi, yi)).x,
+                  read_imagef(src3, n_sampler, (int2)(xi, yi)).x };
+  #else
+    #ifndef P010LE_COMPACT_IN
+    float2 uv = read_imagef(src2, n_sampler, (int2)(xi, yi)).xy;
+    #else
+    off0 = ((xi * 2 + 0) << 1) & 7;
+    off1 = ((xi * 2 + 1) << 1) & 7;
+    pos0 = (int2)((xi * 2 + 0) * 1.25f,     yi);
+    pos1 = (int2)((xi * 2 + 0) * 1.25f + 1, yi);
+    pos2 = (int2)((xi * 2 + 1) * 1.25f,     yi);
+    pos3 = (int2)((xi * 2 + 1) * 1.25f + 1, yi);
+    px4ui.x = read_imageui(src2, n_sampler, pos0).x >> off0 |
+              read_imageui(src2, n_sampler, pos1).x << (8 - off0);
+    px4ui.y = read_imageui(src2, n_sampler, pos2).x >> off1 |
+              read_imageui(src2, n_sampler, pos3).x << (8 - off1);
+    float2 uv = convert_float2((px4ui.xy & 0x3FF) << 6) / USHRT_MAX;
+    #endif
+  #endif
+
+  #ifdef ENABLE_DITHER
+    float d = read_imagef(dither, d_sampler, ncoords_d).x;
+    y0 = get_dithered_y(y0, d);
+    y1 = get_dithered_y(y1, d);
+    y2 = get_dithered_y(y2, d);
+    y3 = get_dithered_y(y3, d);
+  #endif
+
+    write_imagef(dst1, (int2)(x,     y), (float4)(y0, 0.0f, 0.0f, 1.0f));
+    write_imagef(dst1, (int2)(x + 1, y), (float4)(y1, 0.0f, 0.0f, 1.0f));
+    write_imagef(dst1, (int2)(x,     y + 1), (float4)(y2, 0.0f, 0.0f, 1.0f));
+    write_imagef(dst1, (int2)(x + 1, y + 1), (float4)(y3, 0.0f, 0.0f, 1.0f));
+  #if defined(NON_SEMI_PLANAR_OUT) && !defined(SCALE) && !defined(SCALE_BUILTIN)
+    write_imagef(dst2, (int2)(xi, yi), (float4)(uv.x, 0.0f, 0.0f, 1.0f));
+    write_imagef(dst3, (int2)(xi, yi), (float4)(uv.y, 0.0f, 0.0f, 1.0f));
+  #else
+    write_imagef(dst2, (int2)(xi, yi), (float4)(uv.x, uv.y, 0.0f, 1.0f));
+  #endif
+}
+#endif
+
+#ifdef SCALE_BUILTIN
+__kernel void scale_builtin(__write_only image2d_t dst1,
+                            __read_only  image2d_t src1,
+  #ifdef ENABLE_DITHER
+                            __read_only  image2d_t dither,
+  #endif
+                                         int2      src_sz)
+{
+    int2 dst_pos = { get_global_id(0), get_global_id(1) };
+    float2 dst_sz = { get_global_size(0), get_global_size(1) };
+
+    float2 src_pos = (convert_float2(dst_pos) + 0.5f) * convert_float2(src_sz) * native_recip(dst_sz);
+    src_pos = clamp(src_pos, 0.0f, convert_float2(src_sz - 1));
+
+  #if defined(ENABLE_DITHER) && !defined(CONV)
+    float2 ncoords_d = convert_float2(dst_pos) *
+        native_recip((float2)(get_image_width(dither), get_image_height(dither)));
+  #endif
+
+  #ifdef SCALE_BUILTIN_BILINEAR
+    float y = read_imagef(src1, l_sampler, src_pos).x;
+  #else // SCALE_BUILTIN_NEIGHBOR
+    float y = read_imagef(src1, n_sampler, src_pos).x;
+  #endif
+
+  #if defined(ENABLE_DITHER) && !defined(CONV)
+    float d = read_imagef(dither, d_sampler, ncoords_d).x;
+    y = get_dithered_y(y, d);
+  #endif
+
+    write_imagef(dst1, dst_pos, (float4)(y, 0.0f, 0.0f, 1.0f));
+}
+
+__kernel void scale_builtin_uv(__write_only image2d_t dst2,
+                               __read_only  image2d_t src2,
+  #ifdef NON_SEMI_PLANAR_OUT
+                               __write_only image2d_t dst3,
+  #endif
+  #if defined(NON_SEMI_PLANAR_IN) && !defined(CONV)
+                               __read_only  image2d_t src3,
+  #endif
+                                            int2      src_sz)
+{
+    int2 dst_pos = { get_global_id(0), get_global_id(1) };
+    float2 dst_sz = { get_global_size(0), get_global_size(1) };
+
+    float2 src_pos = (convert_float2(dst_pos) + 0.5f) * convert_float2(src_sz) * native_recip(dst_sz);
+    src_pos = clamp(src_pos, 0.0f, convert_float2(src_sz - 1));
+
+  #if defined(NON_SEMI_PLANAR_IN) && !defined(CONV)
+    #ifdef SCALE_BUILTIN_BILINEAR
+    float2 uv = { read_imagef(src2, l_sampler, src_pos).x,
+                  read_imagef(src3, l_sampler, src_pos).x };
+    #else // SCALE_BUILTIN_NEIGHBOR
+    float2 uv = { read_imagef(src2, n_sampler, src_pos).x,
+                  read_imagef(src3, n_sampler, src_pos).x };
+    #endif
+  #else
+    #ifdef SCALE_BUILTIN_BILINEAR
+    float2 uv = read_imagef(src2, l_sampler, src_pos).xy;
+    #else // SCALE_BUILTIN_NEIGHBOR
+    float2 uv = read_imagef(src2, n_sampler, src_pos).xy;
+    #endif
+  #endif
+
+  #ifdef NON_SEMI_PLANAR_OUT
+    write_imagef(dst2, dst_pos, (float4)(uv.x, 0.0f, 0.0f, 1.0f));
+    write_imagef(dst3, dst_pos, (float4)(uv.y, 0.0f, 0.0f, 1.0f));
+  #else
+    write_imagef(dst2, dst_pos, (float4)(uv.x, uv.y, 0.0f, 1.0f));
+  #endif
+}
+#endif
+
+#ifdef SCALE
+__kernel void scale(__write_only image2d_t dst1,
+                    __read_only  image2d_t src1,
+  #ifdef ENABLE_DITHER
+                    __read_only  image2d_t dither,
+  #endif
+                    __constant   float    *cx,
+                    __constant   float    *cy,
+                                 int2      src_sz)
+{
+    int2 dst_pos = { get_global_id(0), get_global_id(1) };
+    float2 dst_sz = { get_global_size(0), get_global_size(1) };
+
+    float2 src_coord = (convert_float2(dst_pos) + 0.5f) * convert_float2(src_sz) * native_recip(dst_sz);
+    int2 src_pos = convert_int2(floor(src_coord - 0.5f));
+
+  #if defined(ENABLE_DITHER) && !defined(CONV)
+    float2 ncoords_d = convert_float2(dst_pos) *
+        native_recip((float2)(get_image_width(dither), get_image_height(dither)));
+  #endif
+
+    int i, j;
+    int filterw2 = filterw >> 1;
+    int filterh2 = filterh >> 1;
+    int2 read_pos, src_sz_edge = src_sz - 1;
+    float4 c1, col1 = 0.0f, s1 = 0.0f;
+
+  #pragma unroll
+    for (i = 0; i < filterh; ++i, s1 = 0.0f) {
+    #pragma unroll
+        for (j = 0; j < filterw; ++j) {
+            read_pos = clamp(src_pos + (int2)(filterw2 - j, filterh2 - i), 0, src_sz_edge);
+            c1 = read_imagef(src1, n_sampler, read_pos);
+            s1 += c1 * cx[dst_pos.x * filterw + j];
+        }
+        col1 += s1 * cy[dst_pos.y * filterh + i];
+    }
+
+    float y = col1.x;
+  #if defined(ENABLE_DITHER) && !defined(CONV)
+    float d = read_imagef(dither, d_sampler, ncoords_d).x;
+    y = get_dithered_y(y, d);
+  #endif
+
+    write_imagef(dst1, dst_pos, (float4)(y, 0.0f, 0.0f, 1.0f));
+}
+
+__kernel void scale_uv(__write_only image2d_t dst2,
+                       __read_only  image2d_t src2,
+  #ifdef NON_SEMI_PLANAR_OUT
+                       __write_only image2d_t dst3,
+  #endif
+  #if defined(NON_SEMI_PLANAR_IN) && !defined(CONV)
+                       __read_only  image2d_t src3,
+  #endif
+                       __constant   float    *cx,
+                       __constant   float    *cy,
+                                    int2      src_sz)
+{
+    int2 dst_pos = { get_global_id(0), get_global_id(1) };
+    float2 dst_sz = { get_global_size(0), get_global_size(1) };
+
+    float2 src_coord = (convert_float2(dst_pos) + 0.5f) * convert_float2(src_sz) * native_recip(dst_sz);
+    int2 src_pos = convert_int2(floor(src_coord - 0.5f));
+
+    int i, j;
+    int filterw2 = filterw >> 1;
+    int filterh2 = filterh >> 1;
+    int2 read_pos, src_sz_edge = src_sz - 1;
+    float4 c2, c3, col2 = 0.0f, col3 = 0.0f, s2 = 0.0f, s3 = 0.0f;
+
+  #pragma unroll
+    for (i = 0; i < filterh; ++i, s2 = s3 = 0.0f) {
+    #pragma unroll
+        for (j = 0; j < filterw; ++j) {
+            read_pos = clamp(src_pos + (int2)(filterw2 - j, filterh2 - i), 0, src_sz_edge);
+            c2 = read_imagef(src2, n_sampler, read_pos);
+            s2 += c2 * cx[dst_pos.x * filterw + j];
+  #ifdef NON_SEMI_PLANAR_IN
+            c3 = read_imagef(src3, n_sampler, read_pos);
+            s3 += c3 * cx[dst_pos.x * filterw + j];
+  #endif
+        }
+        col2 += s2 * cy[dst_pos.y * filterh + i];
+  #ifdef NON_SEMI_PLANAR_IN
+        col3 += s3 * cy[dst_pos.y * filterh + i];
+  #endif
+    }
+
+  #if defined(NON_SEMI_PLANAR_IN) && !defined(CONV)
+    float2 uv = { col2.x, col3.x };
+  #else
+    float2 uv = { col2.x, col2.y };
+  #endif
+
+  #ifdef NON_SEMI_PLANAR_OUT
+    write_imagef(dst2, dst_pos, (float4)(uv.x, 0.0f, 0.0f, 1.0f));
+    write_imagef(dst3, dst_pos, (float4)(uv.y, 0.0f, 0.0f, 1.0f));
+  #else
+    write_imagef(dst2, dst_pos, (float4)(uv.x, uv.y, 0.0f, 1.0f));
+  #endif
+}
+#endif
Index: FFmpeg/libavfilter/opencl_source.h
===================================================================
--- FFmpeg.orig/libavfilter/opencl_source.h
+++ FFmpeg/libavfilter/opencl_source.h
@@ -29,6 +29,7 @@ extern const char *ff_source_nlmeans_cl;
 extern const char *ff_source_overlay_cl;
 extern const char *ff_source_pad_cl;
 extern const char *ff_source_remap_cl;
+extern const char *ff_source_scale_cl;
 extern const char *ff_source_tonemap_cl;
 extern const char *ff_source_transpose_cl;
 extern const char *ff_source_unsharp_cl;
Index: FFmpeg/libavfilter/vf_scale_opencl.c
===================================================================
--- /dev/null
+++ FFmpeg/libavfilter/vf_scale_opencl.c
@@ -0,0 +1,931 @@
+/*
+ * Copyright (c) 2018 Gabriel Machado
+ * Copyright (c) 2021 NyanMisaka
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "libavutil/avassert.h"
+#include "libavutil/imgutils.h"
+#include "libavutil/mem.h"
+#include "libavutil/opt.h"
+#include "libavutil/pixdesc.h"
+
+#include "avfilter.h"
+#include "filters.h"
+#include "opencl.h"
+#include "opencl_source.h"
+#include "scale_eval.h"
+#include "video.h"
+#include "dither_matrix.h"
+
+#define OPENCL_SOURCE_NB 2
+
+static const enum AVPixelFormat supported_formats[] = {
+    AV_PIX_FMT_YUV420P,
+    AV_PIX_FMT_YUV420P16,
+    AV_PIX_FMT_NV12,
+    AV_PIX_FMT_NV15,
+    AV_PIX_FMT_P010,
+    AV_PIX_FMT_P016,
+};
+
+enum filters {
+    F_AREA,
+    F_BICUBIC,
+    F_BILINEAR,
+    F_GAUSSIAN,
+    F_LANCZOS,
+    F_NEIGHBOR,
+    F_SINC,
+    F_SPLINE,
+    F_EXPERIMENTAL
+};
+
+static const int filter_radius[] = {
+    [F_AREA]         =  1,
+    [F_BICUBIC]      =  2,
+    [F_BILINEAR]     =  1,
+    [F_GAUSSIAN]     =  4,
+    [F_LANCZOS]      =  3,
+    [F_NEIGHBOR]     = -1,
+    [F_SINC]         =  10,
+    [F_SPLINE]       =  10,
+    [F_EXPERIMENTAL] =  4
+};
+
+typedef struct ScaleOpenCLContext {
+    OpenCLFilterContext ocf;
+
+    cl_command_queue command_queue;
+    cl_mem           cx, cy;
+    cl_mem           dither_image;
+    cl_kernel        kernel;
+    cl_kernel        kernel_uv;
+    cl_kernel        kernel_conv;
+    const char      *kernel_name;
+    const char      *kernel_name_uv;
+    const char      *kernel_name_conv;
+
+    AVBufferRef     *tmp_hwframes_ctx;
+    AVFrame         *tmp_frame;
+
+    char *w_expr,  *h_expr;
+    int   dst_w,    dst_h;
+    int   src_w,    src_h;
+    int   passthrough;
+    int   algorithm;
+    int   force_original_aspect_ratio;
+    int   force_divisible_by;
+    enum AVPixelFormat format;
+
+    enum AVPixelFormat in_fmt, out_fmt;
+    const AVPixFmtDescriptor *in_desc, *out_desc;
+    int in_planes, out_planes;
+
+    int       filterw, filterh;
+    int       initialised;
+} ScaleOpenCLContext;
+
+static float netravali(float t, float B, float C)
+{
+    if (t > 2) {
+        return 0;
+    } else {
+        float tt  = t * t;
+        float ttt = t * tt;
+        if (t < 1) {
+            return ((12 -  9 * B - 6 * C) * ttt +
+                   (-18 + 12 * B + 6 * C) * tt  +
+                     (6 -  2 * B)) / 6;
+        } else {
+            return     ((-B -  6 * C) * ttt +
+                     (6 * B + 30 * C) * tt +
+                   (-12 * B - 48 * C) * t +
+                     (8 * B + 24 * C)) / 6;
+        }
+    }
+}
+
+static float sinc(float t)
+{
+    return (t == 0) ? 1.0 : sin(t * M_PI) / (t * M_PI);
+}
+
+static float lanczos(float t, float a)
+{
+    return (t < a) ? sinc(t) * sinc(t / a) : 0;
+}
+
+static double spline(double a, double b, double c, double d, double dist)
+{
+    if (dist <= 1.0)
+        return ((d * dist + c) * dist + b) * dist + a;
+    else
+        return spline(0.0,
+                      b + 2.0 * c + 3.0 * d,
+                      c + 3.0 * d,
+                      -b - 3.0 * c - 6.0 * d,
+                      dist - 1.0);
+}
+
+static float calc_weight(int algorithm, float ratio, float t)
+{
+    t = fabs(t);
+
+    switch (algorithm) {
+        case F_AREA: {
+            float t2 = t - 0.5;
+            if (t2 * ratio < -0.5)
+                return 1;
+            else if (t2 * ratio < 0.5)
+                return -t2 * ratio + 0.5;
+            else
+                return 0;
+        }
+
+        case F_BICUBIC: {
+            const float B = 0, C = 0.6;
+            return netravali(t, B, C);
+        }
+
+        case F_BILINEAR:
+            return t < 1 ? (1 - t) : 0;
+
+        case F_EXPERIMENTAL: {
+            double A = 1.0;
+            double c;
+
+            if (t < 1.0)
+                c = cos(t * M_PI);
+            else
+                c = -1.0;
+            if (c < 0.0)
+                c = -pow(-c, A);
+            else
+                c = pow(c, A);
+            return c * 0.5 + 0.5;
+        }
+
+        case F_GAUSSIAN: {
+            const float p = 3.0;
+            return exp2(-p * t * t);
+        }
+
+        case F_LANCZOS: {
+            return lanczos(t, filter_radius[algorithm]);
+        }
+
+        case F_NEIGHBOR:
+            return 1;
+
+        case F_SINC:
+            return sinc(t);
+
+        case F_SPLINE: {
+            const double p = -2.196152422706632;
+            return spline(1.0, 0.0, p, -p - 1.0, t);
+        }
+    }
+
+    return 0;
+}
+
+static av_cold int init_tmp_hwframes_ctx(AVFilterContext *avctx,
+                                         enum AVPixelFormat pix_fmt,
+                                         int width, int height)
+{
+    ScaleOpenCLContext *ctx = avctx->priv;
+    AVFilterLink       *inlink = avctx->inputs[0];
+    FilterLink         *inl    = ff_filter_link(inlink);
+    AVHWFramesContext  *hwfc_in;
+    AVHWFramesContext  *hwfc_tmp;
+    AVBufferRef        *hwfc_tmp_ref;
+    AVHWDeviceContext  *device_ctx;
+    AVBufferRef        *device_ref;
+    int                 ret;
+
+    if (!inl->hw_frames_ctx)
+        return AVERROR(EINVAL);
+
+    hwfc_in = (AVHWFramesContext *)inl->hw_frames_ctx->data;
+    device_ref = hwfc_in->device_ref;
+    device_ctx = (AVHWDeviceContext *)device_ref->data;
+
+    if (!device_ctx || device_ctx->type != AV_HWDEVICE_TYPE_OPENCL) {
+        if (avctx->hw_device_ctx) {
+            device_ref = avctx->hw_device_ctx;
+            device_ctx = (AVHWDeviceContext *)device_ref->data;
+        }
+        if (!device_ctx || device_ctx->type != AV_HWDEVICE_TYPE_OPENCL) {
+            av_log(avctx, AV_LOG_ERROR, "No OpenCL hardware context provided\n");
+            return AVERROR(EINVAL);
+        }
+    }
+
+    hwfc_tmp_ref = av_hwframe_ctx_alloc(device_ref);
+    if (!hwfc_tmp_ref)
+        return AVERROR(ENOMEM);
+
+    hwfc_tmp = (AVHWFramesContext *)hwfc_tmp_ref->data;
+    hwfc_tmp->format    = AV_PIX_FMT_OPENCL;
+    hwfc_tmp->sw_format = pix_fmt;
+    hwfc_tmp->width     = width;
+    hwfc_tmp->height    = height;
+
+    ret = av_hwframe_ctx_init(hwfc_tmp_ref);
+    if (ret < 0) {
+        av_log(avctx, AV_LOG_ERROR, "Error creating frames_ctx for tmp frame: %d\n", ret);
+        av_buffer_unref(&hwfc_tmp_ref);
+        return ret;
+    }
+
+    av_buffer_unref(&ctx->tmp_hwframes_ctx);
+    ctx->tmp_hwframes_ctx = hwfc_tmp_ref;
+
+    return 0;
+}
+
+static int scale_opencl_init(AVFilterContext *avctx)
+{
+    ScaleOpenCLContext *ctx = avctx->priv;
+    AVBPrint header;
+    const char *opencl_sources[OPENCL_SOURCE_NB];
+    size_t m_origin[3] = {0};
+    size_t m_region[3] = {ff_fruit_dither_size, ff_fruit_dither_size, 1};
+    size_t m_row_pitch = ff_fruit_dither_size * sizeof(ff_fruit_dither_matrix[0]);
+    cl_event event;
+    cl_int cle;
+    int i, j, err;
+    float scalex, scaley;
+    float *cx = NULL, *cy = NULL;
+
+    av_bprint_init(&header, 512, AV_BPRINT_SIZE_UNLIMITED);
+
+    if (ctx->src_w == ctx->dst_w && ctx->src_h == ctx->dst_h) {
+        if (ctx->passthrough && ctx->in_fmt == ctx->out_fmt) {
+            ctx->initialised = 1;
+            return 0;
+        } else {
+            av_bprintf(&header, "#define CONV\n");
+            ctx->kernel_name = "conv_yuv";
+        }
+    } else if (ctx->algorithm == F_NEIGHBOR ||
+               ctx->algorithm == F_BILINEAR) {
+        if (ctx->in_fmt == AV_PIX_FMT_NV15) {
+            av_bprintf(&header, "#define CONV\n");
+            ctx->kernel_name_conv = "conv_yuv";
+        }
+        av_bprintf(&header, "#define SCALE_BUILTIN\n");
+        av_bprintf(&header, "#define SCALE_BUILTIN_%s\n",
+            ctx->algorithm == F_BILINEAR ? "BILINEAR" : "NEIGHBOR");
+        ctx->kernel_name = "scale_builtin";
+        ctx->kernel_name_uv = "scale_builtin_uv";
+    } else {
+        if (ctx->in_fmt == AV_PIX_FMT_NV15) {
+            av_bprintf(&header, "#define CONV\n");
+            ctx->kernel_name_conv = "conv_yuv";
+        }
+        av_bprintf(&header, "#define SCALE\n");
+        ctx->kernel_name = "scale";
+        ctx->kernel_name_uv = "scale_uv";
+
+        scalex = FFMAX((float)(ctx->src_w / ctx->dst_w), 1);
+        scaley = FFMAX((float)(ctx->src_h / ctx->dst_h), 1);
+        ctx->filterw = ceil(2 * filter_radius[ctx->algorithm] * scalex);
+        ctx->filterh = ceil(2 * filter_radius[ctx->algorithm] * scaley);
+
+        ctx->filterw = FFMIN(ctx->filterw, ctx->src_w - 2);
+        ctx->filterw = FFMAX(ctx->filterw, 1);
+        ctx->filterh = FFMIN(ctx->filterh, ctx->src_h - 2);
+        ctx->filterh = FFMAX(ctx->filterh, 1);
+
+        av_bprintf(&header, "#define filterw %d\n", ctx->filterw);
+        av_bprintf(&header, "#define filterh %d\n", ctx->filterh);
+
+        av_log(avctx, AV_LOG_DEBUG, "Filter size: %dx%d.\n", ctx->filterw, ctx->filterh);
+
+        cx = av_malloc_array(ctx->dst_w * ctx->filterw, sizeof(cl_float));
+        cy = av_malloc_array(ctx->dst_h * ctx->filterh, sizeof(cl_float));
+
+        if (!cx || !cy) {
+            err = AVERROR(ENOMEM);
+            goto fail;
+        }
+
+        for (i = 0; i < ctx->dst_w; ++i) {
+            float s_x = (i + 0.5) * ctx->src_w / ctx->dst_w - 0.5;
+            float t = s_x - floor(s_x);  // fract
+
+            float sum = 0;
+            for (j = 0; j < ctx->filterw; ++j) {
+                int x = ctx->filterw / 2 - j;
+                sum += cx[i * ctx->filterw + j] = calc_weight(ctx->algorithm,
+                                                              scalex,
+                                                              (x - t) / scalex);
+            }
+
+            for (j = 0; j < ctx->filterw; ++j)
+                cx[i * ctx->filterw + j] /= sum;
+        }
+
+        for (i = 0; i < ctx->dst_h; ++i) {
+            float s_y = (i + 0.5) * ctx->src_h / ctx->dst_h - 0.5;
+            float t = s_y - floor(s_y);  // fract
+
+            float sum = 0;
+            for (j = 0; j < ctx->filterh; ++j) {
+                int y = ctx->filterh / 2 - j;
+                sum += cy[i * ctx->filterh + j] = calc_weight(ctx->algorithm,
+                                                              scaley,
+                                                              (y - t) / scaley);
+            }
+
+            for (j = 0; j < ctx->filterh; ++j)
+                cy[i * ctx->filterh + j] /= sum;
+        }
+
+        ctx->cx = clCreateBuffer(ctx->ocf.hwctx->context,
+                                 CL_MEM_READ_ONLY     |
+                                 CL_MEM_COPY_HOST_PTR |
+                                 CL_MEM_HOST_NO_ACCESS,
+                                 ctx->dst_w * ctx->filterw * sizeof(cl_float),
+                                 cx,
+                                 &cle);
+
+        ctx->cy = clCreateBuffer(ctx->ocf.hwctx->context,
+                                 CL_MEM_READ_ONLY     |
+                                 CL_MEM_COPY_HOST_PTR |
+                                 CL_MEM_HOST_NO_ACCESS,
+                                 ctx->dst_h * ctx->filterh * sizeof(cl_float),
+                                 cy,
+                                 &cle);
+        av_free(cx);
+        av_free(cy);
+        if (!ctx->cx || !ctx->cy) {
+            av_log(avctx, AV_LOG_ERROR, "Failed to create weights buffer: %d.\n", cle);
+            err = AVERROR(EIO);
+            goto fail;
+        }
+    }
+
+    if (ctx->in_planes > 2)
+        av_bprintf(&header, "#define NON_SEMI_PLANAR_IN\n");
+
+    if (ctx->out_planes > 2)
+        av_bprintf(&header, "#define NON_SEMI_PLANAR_OUT\n");
+
+    if (ctx->in_fmt == AV_PIX_FMT_NV15)
+        av_bprintf(&header, "#define P010LE_COMPACT_IN\n");
+
+    if (ctx->in_desc->comp[0].depth > ctx->out_desc->comp[0].depth) {
+        av_bprintf(&header, "#define ENABLE_DITHER\n");
+        av_bprintf(&header, "__constant float dither_size2 = %.4ff;\n", (float)(ff_fruit_dither_size * ff_fruit_dither_size));
+        av_bprintf(&header, "__constant float dither_quantization = %.4ff;\n", (float)((1 << ctx->out_desc->comp[0].depth) - 1));
+    }
+
+    av_log(avctx, AV_LOG_DEBUG, "Generated OpenCL header:\n%s\n", header.str);
+    opencl_sources[0] = header.str;
+    opencl_sources[1] = ff_source_scale_cl;
+    err = ff_opencl_filter_load_program(avctx, opencl_sources, OPENCL_SOURCE_NB);
+
+    av_bprint_finalize(&header, NULL);
+    if (err < 0)
+        goto fail;
+
+    ctx->command_queue = clCreateCommandQueue(ctx->ocf.hwctx->context,
+                                              ctx->ocf.hwctx->device_id,
+                                              0, &cle);
+    if (!ctx->command_queue) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to create OpenCL command queue: %d.\n", cle);
+        err = AVERROR(EIO);
+        goto fail;
+    }
+
+    if (ctx->in_desc->comp[0].depth > ctx->out_desc->comp[0].depth) {
+        cl_image_format image_format = {
+            .image_channel_data_type = CL_UNORM_INT16,
+            .image_channel_order     = CL_R,
+        };
+        cl_image_desc image_desc = {
+            .image_type      = CL_MEM_OBJECT_IMAGE2D,
+            .image_width     = ff_fruit_dither_size,
+            .image_height    = ff_fruit_dither_size,
+            .image_row_pitch = 0,
+        };
+
+        av_assert0(sizeof(ff_fruit_dither_matrix) == sizeof(ff_fruit_dither_matrix[0]) * ff_fruit_dither_size * ff_fruit_dither_size);
+
+        ctx->dither_image = clCreateImage(ctx->ocf.hwctx->context, CL_MEM_READ_ONLY,
+                                          &image_format, &image_desc, NULL, &cle);
+        if (!ctx->dither_image) {
+            av_log(avctx, AV_LOG_ERROR, "Failed to create image for "
+                   "dither matrix: %d.\n", cle);
+            err = AVERROR(EIO);
+            goto fail;
+        }
+
+        cle = clEnqueueWriteImage(ctx->command_queue,
+                                  ctx->dither_image,
+                                  CL_FALSE, m_origin, m_region,
+                                  m_row_pitch, 0,
+                                  ff_fruit_dither_matrix,
+                                  0, NULL, &event);
+        CL_FAIL_ON_ERROR(AVERROR(EIO), "Failed to enqueue write of dither matrix image: %d.\n", cle);
+
+        cle = clWaitForEvents(1, &event);
+        CL_FAIL_ON_ERROR(AVERROR(EIO), "Failed to wait for event completion: %d.\n", cle);
+    }
+
+    ctx->kernel = clCreateKernel(ctx->ocf.program, ctx->kernel_name, &cle);
+    if (!ctx->kernel) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to create kernel: %d.\n", cle);
+        err = AVERROR(EIO);
+        goto fail;
+    }
+
+    if (ctx->kernel_name_uv) {
+        ctx->kernel_uv = clCreateKernel(ctx->ocf.program, ctx->kernel_name_uv, &cle);
+        if (!ctx->kernel_uv) {
+            av_log(avctx, AV_LOG_ERROR, "Failed to create kernel_uv: %d.\n", cle);
+            err = AVERROR(EIO);
+            goto fail;
+        }
+    }
+
+    if (ctx->kernel_name_conv) {
+        enum AVPixelFormat tmp_fmt;
+        av_assert0(ctx->in_fmt == AV_PIX_FMT_NV15);
+
+        ctx->kernel_conv = clCreateKernel(ctx->ocf.program, ctx->kernel_name_conv, &cle);
+        if (!ctx->kernel_conv) {
+            av_log(avctx, AV_LOG_ERROR, "Failed to create kernel_conv: %d.\n", cle);
+            err = AVERROR(EIO);
+            goto fail;
+        }
+        /* for scaling P010 compact: 1st pass conv & 2nd pass scale */
+        tmp_fmt = ctx->out_desc->comp[0].depth <= 8 ? AV_PIX_FMT_NV12 : AV_PIX_FMT_P010;
+        if ((err = init_tmp_hwframes_ctx(avctx, tmp_fmt, ctx->src_w, ctx->src_h)) < 0)
+            goto fail;
+
+        if (ctx->tmp_frame)
+            av_frame_free(&ctx->tmp_frame);
+
+        ctx->tmp_frame = av_frame_alloc();
+        if (!ctx->tmp_frame) {
+            err = AVERROR(ENOMEM);
+            goto fail;
+        }
+        if ((err = av_hwframe_get_buffer(ctx->tmp_hwframes_ctx, ctx->tmp_frame, 0)) < 0) {
+            av_buffer_unref(&ctx->tmp_hwframes_ctx);
+            goto fail;
+        }
+    }
+
+    ctx->initialised = 1;
+    return 0;
+
+fail:
+    av_bprint_finalize(&header, NULL);
+    if (ctx->command_queue)
+        clReleaseCommandQueue(ctx->command_queue);
+    if (ctx->kernel)
+        clReleaseKernel(ctx->kernel);
+    if (ctx->kernel_uv)
+        clReleaseKernel(ctx->kernel_uv);
+    if (ctx->kernel_conv)
+        clReleaseKernel(ctx->kernel_conv);
+    if (event)
+        clReleaseEvent(event);
+    if (ctx->dither_image)
+        clReleaseMemObject(ctx->dither_image);
+    if (ctx->cx)
+        clReleaseMemObject(ctx->cx);
+    if (ctx->cy)
+        clReleaseMemObject(ctx->cy);
+    if (cx)
+        av_free(cx);
+    if (cy)
+        av_free(cy);
+    return err;
+}
+
+static int format_is_supported(enum AVPixelFormat fmt)
+{
+    for (int i = 0; i < FF_ARRAY_ELEMS(supported_formats); i++)
+        if (supported_formats[i] == fmt)
+            return 1;
+    return 0;
+}
+
+static int scale_opencl_config_output(AVFilterLink *outlink)
+{
+    FilterLink        *outl = ff_filter_link(outlink);
+    AVFilterContext  *avctx = outlink->src;
+    AVFilterLink    *inlink = avctx->inputs[0];
+    FilterLink         *inl = ff_filter_link(inlink);
+    ScaleOpenCLContext *ctx = avctx->priv;
+    AVHWFramesContext *in_frames_ctx;
+    enum AVPixelFormat in_format;
+    enum AVPixelFormat out_format;
+    const AVPixFmtDescriptor *in_desc;
+    const AVPixFmtDescriptor *out_desc;
+    int ret;
+
+    if (!inl->hw_frames_ctx)
+        return AVERROR(EINVAL);
+    in_frames_ctx = (AVHWFramesContext*)inl->hw_frames_ctx->data;
+    in_format     = in_frames_ctx->sw_format;
+    out_format    = (ctx->format == AV_PIX_FMT_NONE) ? in_format : ctx->format;
+    in_desc       = av_pix_fmt_desc_get(in_format);
+    out_desc      = av_pix_fmt_desc_get(out_format);
+
+    if (!format_is_supported(in_format)) {
+        av_log(ctx, AV_LOG_ERROR, "Unsupported input format: %s\n",
+               av_get_pix_fmt_name(in_format));
+        return AVERROR(ENOSYS);
+    }
+    if (!format_is_supported(out_format)) {
+        av_log(ctx, AV_LOG_ERROR, "Unsupported output format: %s\n",
+               av_get_pix_fmt_name(out_format));
+        return AVERROR(ENOSYS);
+    }
+
+    ctx->in_fmt     = in_format;
+    ctx->out_fmt    = out_format;
+    ctx->in_desc    = in_desc;
+    ctx->out_desc   = out_desc;
+    ctx->in_planes  = av_pix_fmt_count_planes(ctx->in_fmt);
+    ctx->out_planes = av_pix_fmt_count_planes(ctx->out_fmt);
+    ctx->ocf.output_format = out_format;
+
+    if ((ret = ff_scale_eval_dimensions(ctx,
+                                        ctx->w_expr, ctx->h_expr,
+                                        inlink, outlink,
+                                        &ctx->dst_w, &ctx->dst_h)) < 0)
+        return ret;
+
+    ff_scale_adjust_dimensions(inlink, &ctx->dst_w, &ctx->dst_h,
+                               ctx->force_original_aspect_ratio, ctx->force_divisible_by);
+
+    if (((int64_t)ctx->dst_h * inlink->w) > INT_MAX ||
+        ((int64_t)ctx->dst_w * inlink->h) > INT_MAX)
+        av_log(ctx, AV_LOG_ERROR, "Rescaled value for width or height is too big.\n");
+
+    ctx->src_w = inlink->w;
+    ctx->src_h = inlink->h;
+    ctx->ocf.output_width  = ctx->dst_w;
+    ctx->ocf.output_height = ctx->dst_h;
+
+    if (ctx->passthrough && ctx->src_w == ctx->dst_w && ctx->src_h == ctx->dst_h && ctx->in_fmt == ctx->out_fmt) {
+        av_buffer_unref(&outl->hw_frames_ctx);
+        outl->hw_frames_ctx = av_buffer_ref(inl->hw_frames_ctx);
+        if (!outl->hw_frames_ctx)
+            return AVERROR(ENOMEM);
+        return 0;
+    } else {
+        ctx->passthrough = 0;
+        if (out_format == AV_PIX_FMT_NV15) {
+            av_log(ctx, AV_LOG_ERROR, "Unsupported output format: %s\n",
+                   av_get_pix_fmt_name(out_format));
+            return AVERROR(ENOSYS);
+        }
+    }
+
+    ret = ff_opencl_filter_config_output(outlink);
+    if (ret < 0)
+        return ret;
+
+    return 0;
+}
+
+static AVFrame *scale_opencl_get_video_buffer(AVFilterLink *inlink, int w, int h)
+{
+    ScaleOpenCLContext *ctx = inlink->dst->priv;
+
+    return ctx->passthrough ? ff_null_get_video_buffer(inlink, w, h) :
+                              ff_default_get_video_buffer(inlink, w, h);
+}
+
+static int scale_opencl_filter_frame_internal(AVFilterLink *inlink,
+                                              AVFrame *input, AVFrame *output,
+                                              int in_planes, int out_planes, int conv)
+{
+    AVFilterContext     *avctx = inlink->dst;
+    ScaleOpenCLContext    *ctx = avctx->priv;
+    int x_subsample = 1 << ctx->in_desc->log2_chroma_w;
+    int y_subsample = 1 << ctx->in_desc->log2_chroma_h;
+    size_t global_work[2];
+    cl_kernel kernel = (conv && ctx->kernel_conv) ? ctx->kernel_conv : ctx->kernel;
+    cl_int cle;
+    cl_int2 src_size, uv_size;
+    int err, idx_arg1, idx_arg2;
+
+    if (!output->data[0] || !input->data[0] || !output->data[1] || !input->data[1]) {
+        err = AVERROR(EIO);
+        goto fail;
+    }
+
+    if (out_planes > 2 && !output->data[2]) {
+        err = AVERROR(EIO);
+        goto fail;
+    }
+
+    if (in_planes > 2 && !input->data[2]) {
+        err = AVERROR(EIO);
+        goto fail;
+    }
+
+    CL_SET_KERNEL_ARG(kernel, 0, cl_mem, &output->data[0]);
+    CL_SET_KERNEL_ARG(kernel, 1, cl_mem, &input->data[0]);
+
+    if (conv) {
+        CL_SET_KERNEL_ARG(kernel, 2, cl_mem, &output->data[1]);
+        CL_SET_KERNEL_ARG(kernel, 3, cl_mem, &input->data[1]);
+
+        idx_arg1 = 4;
+        if (out_planes > 2) {
+            CL_SET_KERNEL_ARG(kernel, idx_arg1++, cl_mem, &output->data[2]);
+        }
+        if (in_planes > 2) {
+            CL_SET_KERNEL_ARG(kernel, idx_arg1++, cl_mem, &input->data[2]);
+        }
+        if (ctx->dither_image) {
+            CL_SET_KERNEL_ARG(kernel, idx_arg1++, cl_mem, &ctx->dither_image);
+        }
+
+        // conv_yuv
+        global_work[0] = output->width / x_subsample;
+        global_work[1] = output->height / y_subsample;
+
+        av_log(avctx, AV_LOG_DEBUG, "Run kernel conv_yuv "
+               "(%"SIZE_SPECIFIER"x%"SIZE_SPECIFIER").\n",
+               global_work[0], global_work[1]);
+
+        cle = clEnqueueNDRangeKernel(ctx->command_queue, kernel, 2, NULL,
+                                     global_work, NULL, 0, NULL, NULL);
+        CL_FAIL_ON_ERROR(AVERROR(EIO), "Failed to enqueue kernel: %d.\n", cle);
+    } else {
+        CL_SET_KERNEL_ARG(ctx->kernel_uv, 0, cl_mem, &output->data[1]);
+        CL_SET_KERNEL_ARG(ctx->kernel_uv, 1, cl_mem, &input->data[1]);
+
+        idx_arg1 = 2;
+        if (ctx->out_planes > 2) {
+            CL_SET_KERNEL_ARG(ctx->kernel_uv, idx_arg1++, cl_mem, &output->data[2]);
+        }
+        if (ctx->in_planes > 2) {
+            CL_SET_KERNEL_ARG(ctx->kernel_uv, idx_arg1++, cl_mem, &input->data[2]);
+        }
+
+        idx_arg2 = 2;
+        if (ctx->dither_image) {
+            CL_SET_KERNEL_ARG(ctx->kernel, idx_arg2++, cl_mem, &ctx->dither_image);
+        }
+        if (!(ctx->algorithm == F_NEIGHBOR || ctx->algorithm == F_BILINEAR)) {
+            CL_SET_KERNEL_ARG(ctx->kernel, idx_arg2++, cl_mem, &ctx->cx);
+            CL_SET_KERNEL_ARG(ctx->kernel, idx_arg2++, cl_mem, &ctx->cy);
+
+            CL_SET_KERNEL_ARG(ctx->kernel_uv, idx_arg1++, cl_mem, &ctx->cx);
+            CL_SET_KERNEL_ARG(ctx->kernel_uv, idx_arg1++, cl_mem, &ctx->cy);
+        }
+
+        src_size.s[0] = ctx->src_w;
+        src_size.s[1] = ctx->src_h;
+        uv_size.s[0] = src_size.s[0] / x_subsample;
+        uv_size.s[1] = src_size.s[1] / y_subsample;
+        CL_SET_KERNEL_ARG(ctx->kernel, idx_arg2++, cl_int2, &src_size);
+        CL_SET_KERNEL_ARG(ctx->kernel_uv, idx_arg1++, cl_int2, &uv_size);
+
+        // scale, scale_builtin
+        global_work[0] = output->width;
+        global_work[1] = output->height;
+
+        av_log(avctx, AV_LOG_DEBUG, "Run kernel %s "
+               "(%"SIZE_SPECIFIER"x%"SIZE_SPECIFIER").\n",
+               ctx->kernel_name, global_work[0], global_work[1]);
+
+        cle = clEnqueueNDRangeKernel(ctx->command_queue, ctx->kernel, 2, NULL,
+                                     global_work, NULL, 0, NULL, NULL);
+        CL_FAIL_ON_ERROR(AVERROR(EIO), "Failed to enqueue kernel: %d.\n", cle);
+
+        // scale_uv, scale_builtin_uv
+        global_work[0] = output->width / x_subsample;
+        global_work[1] = output->height / y_subsample;
+
+        av_log(avctx, AV_LOG_DEBUG, "Run kernel %s "
+               "(%"SIZE_SPECIFIER"x%"SIZE_SPECIFIER").\n",
+               ctx->kernel_name_uv, global_work[0], global_work[1]);
+
+        cle = clEnqueueNDRangeKernel(ctx->command_queue, ctx->kernel_uv, 2, NULL,
+                                     global_work, NULL, 0, NULL, NULL);
+        CL_FAIL_ON_ERROR(AVERROR(EIO), "Failed to enqueue kernel: %d.\n", cle);
+    }
+
+    return 0;
+
+fail:
+    return err;
+}
+
+static int scale_opencl_filter_frame(AVFilterLink *inlink, AVFrame *input)
+{
+    AVFilterContext     *avctx = inlink->dst;
+    AVFilterLink      *outlink = avctx->outputs[0];
+    ScaleOpenCLContext    *ctx = avctx->priv;
+    AVFrame *output = NULL;
+    cl_int cle;
+    int err;
+
+    av_log(ctx, AV_LOG_DEBUG, "Filter input: %s, %ux%u (%"PRId64").\n",
+           av_get_pix_fmt_name(input->format),
+           input->width, input->height, input->pts);
+
+    if (!input->hw_frames_ctx)
+        return AVERROR(EINVAL);
+
+    if (!ctx->initialised) {
+        err = scale_opencl_init(avctx);
+        if (err < 0)
+            goto fail;
+    }
+
+    if (ctx->passthrough && ctx->src_w == ctx->dst_w && ctx->src_h == ctx->dst_h && ctx->in_fmt == ctx->out_fmt)
+        return ff_filter_frame(outlink, input);
+
+    output = ff_get_video_buffer(outlink, outlink->w, outlink->h);
+    if (!output) {
+        err = AVERROR(ENOMEM);
+        goto fail;
+    }
+
+    err = av_frame_copy_props(output, input);
+    if (err < 0)
+        goto fail;
+    output->width  = outlink->w;
+    output->height = outlink->h;
+
+    if (ctx->in_fmt == AV_PIX_FMT_NV15 && !(ctx->src_w == ctx->dst_w && ctx->src_h == ctx->dst_h)) {
+        /* for scaling P010 compact: 1st pass conv & 2nd pass scale */
+        if ((err = scale_opencl_filter_frame_internal(inlink, input, ctx->tmp_frame, ctx->in_planes, 2, 1)) < 0)
+            goto fail;
+        if ((err = scale_opencl_filter_frame_internal(inlink, ctx->tmp_frame, output, 2, ctx->out_planes, 0)) < 0)
+            goto fail;
+    } else {
+        if ((err = scale_opencl_filter_frame_internal(inlink, input, output, ctx->in_planes, ctx->out_planes,
+                                                      ctx->src_w == ctx->dst_w && ctx->src_h == ctx->dst_h)) < 0)
+            goto fail;
+    }
+
+    cle = clFinish(ctx->command_queue);
+    CL_FAIL_ON_ERROR(AVERROR(EIO), "Failed to finish command queue: %d.\n", cle);
+
+    av_frame_free(&input);
+
+    av_log(ctx, AV_LOG_DEBUG, "Filter output: %s, %ux%u (%"PRId64").\n",
+           av_get_pix_fmt_name(output->format),
+           output->width, output->height, output->pts);
+
+    return ff_filter_frame(outlink, output);
+
+fail:
+    clFinish(ctx->command_queue);
+    av_frame_free(&input);
+    av_frame_free(&output);
+    return err;
+}
+
+static av_cold void scale_opencl_uninit(AVFilterContext *avctx)
+{
+    ScaleOpenCLContext *ctx = avctx->priv;
+    cl_int cle;
+
+    if (ctx->tmp_frame)
+        av_frame_free(&ctx->tmp_frame);
+
+    if (ctx->tmp_hwframes_ctx)
+        av_buffer_unref(&ctx->tmp_hwframes_ctx);
+
+    if (ctx->kernel) {
+        cle = clReleaseKernel(ctx->kernel);
+        if (cle != CL_SUCCESS)
+            av_log(avctx, AV_LOG_ERROR, "Failed to release "
+                   "kernel: %d.\n", cle);
+    }
+
+    if (ctx->kernel_uv) {
+        cle = clReleaseKernel(ctx->kernel_uv);
+        if (cle != CL_SUCCESS)
+            av_log(avctx, AV_LOG_ERROR, "Failed to release "
+                   "kernel_uv: %d.\n", cle);
+    }
+
+    if (ctx->kernel_conv) {
+        cle = clReleaseKernel(ctx->kernel_conv);
+        if (cle != CL_SUCCESS)
+            av_log(avctx, AV_LOG_ERROR, "Failed to release "
+                   "kernel_conv: %d.\n", cle);
+    }
+
+    if (ctx->command_queue) {
+        cle = clReleaseCommandQueue(ctx->command_queue);
+        if (cle != CL_SUCCESS)
+            av_log(avctx, AV_LOG_ERROR, "Failed to release "
+                   "command queue: %d.\n", cle);
+    }
+
+    if (ctx->cx) {
+        cle = clReleaseMemObject(ctx->cx);
+        if (cle != CL_SUCCESS)
+            av_log(avctx, AV_LOG_ERROR, "Failed to release "
+            "weights buffer: %d.\n", cle);
+    }
+
+    if (ctx->cy) {
+        cle = clReleaseMemObject(ctx->cy);
+        if (cle != CL_SUCCESS)
+            av_log(avctx, AV_LOG_ERROR, "Failed to release "
+            "weights buffer: %d.\n", cle);
+    }
+
+    if (ctx->dither_image) {
+        cle = clReleaseMemObject(ctx->dither_image);
+        if (cle != CL_SUCCESS)
+            av_log(avctx, AV_LOG_ERROR, "Failed to release "
+            "dither image: %d.\n", cle);
+    }
+
+    ff_opencl_filter_uninit(avctx);
+}
+
+#define OFFSET(x) offsetof(ScaleOpenCLContext, x)
+#define FLAGS (AV_OPT_FLAG_FILTERING_PARAM | AV_OPT_FLAG_VIDEO_PARAM)
+static const AVOption scale_opencl_options[] = {
+    { "w",           "Output video width",                               OFFSET(w_expr),      AV_OPT_TYPE_STRING,    { .str = "iw"            }, .flags = FLAGS },
+    { "h",           "Output video height",                              OFFSET(h_expr),      AV_OPT_TYPE_STRING,    { .str = "ih"            }, .flags = FLAGS },
+    { "format",      "Output pixel format",                              OFFSET(format),      AV_OPT_TYPE_PIXEL_FMT, { .i64 = AV_PIX_FMT_NONE }, AV_PIX_FMT_NONE, INT_MAX, FLAGS, .unit = "fmt" },
+    { "passthrough", "Do not process frames at all if parameters match", OFFSET(passthrough), AV_OPT_TYPE_BOOL,      { .i64 = 0               }, 0, 1, FLAGS },
+    { "algo",        "Scaling algorithm",                                OFFSET(algorithm),   AV_OPT_TYPE_INT,       { .i64 = F_BILINEAR      }, INT_MIN, INT_MAX, FLAGS, .unit = "algo" },
+        { "area",         "Area averaging",   0, AV_OPT_TYPE_CONST, { .i64 = F_AREA         }, 0, 0, FLAGS, .unit = "algo" },
+        { "bicubic",      "Bicubic",          0, AV_OPT_TYPE_CONST, { .i64 = F_BICUBIC      }, 0, 0, FLAGS, .unit = "algo" },
+        { "bilinear",     "Bilinear",         0, AV_OPT_TYPE_CONST, { .i64 = F_BILINEAR     }, 0, 0, FLAGS, .unit = "algo" },
+        { "gauss",        "Gaussian",         0, AV_OPT_TYPE_CONST, { .i64 = F_GAUSSIAN     }, 0, 0, FLAGS, .unit = "algo" },
+        { "lanczos",      "Lanczos",          0, AV_OPT_TYPE_CONST, { .i64 = F_LANCZOS      }, 0, 0, FLAGS, .unit = "algo" },
+        { "neighbor",     "Nearest Neighbor", 0, AV_OPT_TYPE_CONST, { .i64 = F_NEIGHBOR     }, 0, 0, FLAGS, .unit = "algo" },
+        { "sinc",         "Sinc",             0, AV_OPT_TYPE_CONST, { .i64 = F_SINC         }, 0, 0, FLAGS, .unit = "algo" },
+        { "spline",       "Bicubic Spline",   0, AV_OPT_TYPE_CONST, { .i64 = F_SPLINE       }, 0, 0, FLAGS, .unit = "algo" },
+        { "experimental", "Experimental",     0, AV_OPT_TYPE_CONST, { .i64 = F_EXPERIMENTAL }, 0, 0, FLAGS, .unit = "algo" },
+    { "force_original_aspect_ratio", "Decrease or increase w/h if necessary to keep the original AR", OFFSET(force_original_aspect_ratio), AV_OPT_TYPE_INT, { .i64 = 1 }, 0, 2, FLAGS, .unit = "force_oar" },
+        { "disable",       NULL,              0, AV_OPT_TYPE_CONST, {.i64 = 0 }, 0, 0, FLAGS, .unit = "force_oar" },
+        { "decrease",      NULL,              0, AV_OPT_TYPE_CONST, {.i64 = 1 }, 0, 0, FLAGS, .unit = "force_oar" },
+        { "increase",      NULL,              0, AV_OPT_TYPE_CONST, {.i64 = 2 }, 0, 0, FLAGS, .unit = "force_oar" },
+    { "force_divisible_by", "Enforce that the output resolution is divisible by a defined integer when force_original_aspect_ratio is used", OFFSET(force_divisible_by), AV_OPT_TYPE_INT, { .i64 = 2 }, 1, 256, FLAGS },
+    { NULL }
+};
+
+AVFILTER_DEFINE_CLASS(scale_opencl);
+
+static const AVFilterPad scale_opencl_inputs[] = {
+    {
+        .name             = "default",
+        .type             = AVMEDIA_TYPE_VIDEO,
+        .filter_frame     = &scale_opencl_filter_frame,
+        .get_buffer.video = &scale_opencl_get_video_buffer,
+        .config_props     = &ff_opencl_filter_config_input,
+    },
+};
+
+static const AVFilterPad scale_opencl_outputs[] = {
+    {
+        .name         = "default",
+        .type         = AVMEDIA_TYPE_VIDEO,
+        .config_props = &scale_opencl_config_output,
+    },
+};
+
+const AVFilter ff_vf_scale_opencl = {
+    .name           = "scale_opencl",
+    .description    = NULL_IF_CONFIG_SMALL("Scale the input video size through OpenCL."),
+    .priv_size      = sizeof(ScaleOpenCLContext),
+    .priv_class     = &scale_opencl_class,
+    .init           = &ff_opencl_filter_init,
+    .uninit         = &scale_opencl_uninit,
+    FILTER_INPUTS(scale_opencl_inputs),
+    FILTER_OUTPUTS(scale_opencl_outputs),
+    FILTER_SINGLE_PIXFMT(AV_PIX_FMT_OPENCL),
+    .flags_internal = FF_FILTER_FLAG_HWFRAME_AWARE,
+    .flags          = AVFILTER_FLAG_HWDEVICE,
+};
